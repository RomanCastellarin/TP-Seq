\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage[pdftex]{graphicx}
\usepackage{float}
\usepackage{booktabs}
\usepackage[table,xcdraw]{xcolor}
\usepackage{ltxtable}
\usepackage{listings}
\lstset{language=Haskell}
\usepackage{color}
\begin{document}
\begin{titlepage}

\begin{minipage}{2.6cm}
\includegraphics[width=\textwidth]{fceia.pdf}
\end{minipage}
\hfill
%
\begin{minipage}{6cm}
\begin{center}
\normalsize{Universidad Nacional de Rosario\\
Facultad de Ciencias Exactas,\\
Ingeniería y Agrimensura\\}
\end{center}
\end{minipage}
\hspace{0.5cm}
\hfill
\begin{minipage}{2.6cm}
\includegraphics[width=\textwidth]{unr.pdf}
\end{minipage}

\vspace{0.5cm}

\begin{center}
\normalsize{\sc Estructuras de Datos II}\\
\vspace{0.5cm}
\large{Trabajo Práctico II}\\

\Large{\bf Secuencias}\\
\vspace{5cm}

\normalsize
Román Castellarin\\
Juan Ignacio Suarez\\

\vspace*{0.5cm}
\small{ \today }


\end{center}
\end{titlepage}
\newpage

\section{Implementacion basada en Arrays Persistentes}

\begin{tabular}{@{}lcc@{}}
\toprule
        & W & S \\ \midrule
filterS p x & $O(|x| + \sum\limits_{i=0}^{|x|-1} W[p\ x_i])$  &  $(\log |x| + \max\limits_{i=0}^{|x|-1} S[p\ x_i])$  \\
reduceS f e s & $ O(|s| + \sum\limits_{(x\oplus y)\in\mathcal{O}_r(\oplus,e,s)} W[x\oplus y])$  &  $ O(\log |s|\cdot \max\limits_{(x\oplus y)\in\mathcal{O}_r(\oplus,e,s)} S[x\oplus y])$ \\
scanS   & $O(|s| + \sum\limits_{(x\oplus y)\in\mathcal{O}_s(\oplus,e,s)} W[x\oplus y])$  &  $O(\log |s|\cdot \max\limits_{(x\oplus y)\in\mathcal{O}_s(\oplus,e,s)} S[x\oplus y])$ \\
showtS  & $O(1)$  &  $O(1)$ \\ \bottomrule
\end{tabular}

\subsection{filterA es $O(|x| + \sum\limits_{i=0}^{|x|-1} W[p\ x_i])$ en trabajo.\\ y $O(\log |x| + \max\limits_{i=0}^{|x|-1} S[p\ x_i])$ en profundidad.}
\begin{table}[h]
\begin{lstlisting}
filterA p x = A.flatten (mapA g x)
    where g y = if p y then singletonA y else emptyA
\end{lstlisting}
\caption{Definicion de filterA}
\end{table}
\begin{table}[h]
\begin{lstlisting}
emptyA = A.fromList []
singletonA x = A.fromList [x]
mapA f x = A.tabulate g (A.length x)
    where g n = f (x ! n)
\end{lstlisting}
\caption{Definicion de emptyA, singletonA y mapA}
\end{table}
\begin{itemize}
\item \textbf{Lema:} \texttt{singletonA} y \texttt{emptyA} son $O(1)$ en trabajo y profundidad.

 \textit{Dem:} Ambas hacen una cantidad constante de operaciones independientemente de la entrada.
 
\item \textbf{Lema:} \texttt{mapA f s} es $O( \sum\limits_{i=0}^{|s|-1} W[f\ s_i] )$ en trabajo y $O( \max\limits_{i=0}^{|s|-1} S[f\ s_i] )$ en profundidad.

 \textit{Dem:} Se desprende como corolario de las cotas de \texttt{tabulate g n} con $g\ i = f\ s_i$ y $n=|s|$. 
 
\end{itemize}

Concentremonos en la definicion de \texttt{filterA} presentada arriba:
\begin{itemize}
\item Del primer lema, resulta que $W[g\ y]\in O(W[p\ y])$ y $S[g\ y]\in O(S[p\ y])$.
\item Del segundo lema, resulta que \texttt{map\ g\ x} es $O(\sum\limits_{i=0}^{|x|-1} W[p\ x_i])$ en trabajo y $O(\max\limits_{i=0}^{|x|-1} S[p\ x_i])$ en profundidad.
\item Es necesario calcular primero \texttt{map\ g\ x} para luego aplicar el \texttt{flatten}, por lo que las profundidades y trabajos se suman ya que no se realizan en paralelo.
\item Tenemos entonces por la especificacion dada de \texttt{flatten} que \texttt{filter\ p\ x} es $O(|x| + \sum\limits_{i=0}^{|x|-1} W[p\ x_i])$ en trabajo ya que $|g\ y| \in O(1)$, mientras que en profundidad es $O(\log |x| + \max\limits_{i=0}^{|x|-1} S[p\ x_i])$.
\end{itemize}


\subsection{reduceA es $O(|s| + \sum\limits_{(x\oplus y)\in\mathcal{O}_r(\oplus,e,s)} W[x\oplus y])$ en trabajo,\\
y $ O(\log |s|\cdot \max\limits_{(x\oplus y)\in\mathcal{O}_r(\oplus,e,s)} S[x\oplus y])$ en profundidad.}

Utilizaremos $\mathcal{O}_r(\oplus,e,s)$ para denotar el conjunto de aplicaciones de $\oplus$ al invocar \texttt{reduceA $\oplus$ e s}. Notemos que para reducir una secuencia de largo $n$ por aplicacion repetida de $\oplus$ (en cualquier orden) hacen falta $n-1$ aplicaciones, por lo que cardinalidad de este conjunto es $O(|s|)$.

Para el analisis general de costo, supondremos primero que $W[x \oplus y]$ es $O(1)$, y luego deduciremos el caso general.

\begin{table}[h!]
\begin{lstlisting}
reduceA f e s = case A.length s of
    0 -> e
    _ -> f e (reduceByContraction f s)
    where reduceByContraction f s = case A.length s of
            1 -> s ! 0
            _ -> reduceByContraction f (contractA f s)
\end{lstlisting}
\caption{Definicion de reduceA}
\end{table}

\begin{table}[h!]
\begin{lstlisting}
contractA f s | n == 1    = s
              | even n    = A.tabulate g  (n//2)
              | otherwise = A.tabulate g' (n//2 + 1)
    where n = A.length s
          g i = f (s ! (2*i)) (s ! (2*i + 1))
          g' i = if i == (n//2) then s ! (2*i) else g i
\end{lstlisting}
\caption{Definicion de contractA}
\end{table}

\begin{itemize}
\item \textbf{Lema:} Para $W_\oplus,S_\oplus \in O(1)$, \texttt{contractA $\oplus$ s} es $O(|s|)$ en trabajo y $O(1)$ en profundidad:

 \textit{Dem:} Corolario de las cotas de \texttt{tabulate g n} con $g\ i = s_{2i}\oplus s_{2i+1}$ y $n\in O(|s|)$.
\end{itemize}
\begin{itemize}
\item Veamos que como \texttt{contract} reduce la longitud de la secuencia en un factor de $1/2$, \texttt{reduceByContraction} solo recursa $O(\log |s|)$ veces, y por lo tanto (usando el lema anterior) resulta $O(\log |s|)$ en profundidad.\\
En simbolos: $S(n) = S(n/2) + O(1) \Rightarrow S \in O(\log n)$

\item Para el trabajo, (usando el lema anterior) veamos que obtenemos una serie geometrica, por lo que resulta $O(|s|)$.\\
En simbolos: $W(n) = W(n/2) + O(n) \Rightarrow S \in O(n)$
\end{itemize}
Para una especificacion de costos general, notemos que solo debemos agregarle al trabajo obtenido, el trabajo de cada operacion ($x\oplus y$) hecho, y la profundidad no puede empeorar mas que en un factor $\max\limits_{(x\oplus y)\in\mathcal{O}_r(\oplus,e,s)} S[x\oplus y]$.

Por lo que finalmente obtenemos:
$$O(|s| + \sum\limits_{(x\oplus y)\in\mathcal{O}_r(\oplus,e,s)} W[x\oplus y])$$ en trabajo, y

$$ O(\log |s|\cdot \max\limits_{(x\oplus y)\in\mathcal{O}_r(\oplus,e,s)} S[x\oplus y])$$ en profundidad.

\subsubsection{scanA es $O(|s| + \sum\limits_{(x\oplus y)\in\mathcal{O}_s(\oplus,e,s)} W[x\oplus y])$ en trabajo,\\
y $ O(\log |s|\cdot \max\limits_{(x\oplus y)\in\mathcal{O}_s(\oplus,e,s)} S[x\oplus y])$ en profundidad.}



\begin{table}[h]
\begin{lstlisting}
scanA f e s = (scan_seq, scan_last)
    where (scan_seq, scan_last) = (scanA' f e s) ||| (reduceA f e s)
          scanA' f e s = case A.length s of
            0 -> emptyA
            1 -> singletonA e
            n -> tabulateA g n
            where s' = scanA' f e (contractA f s)
                  g i | even i    = s' ! (i//2)
                      | otherwise = f (s' ! (i//2)) (s ! (i-1))
\end{lstlisting}
\caption{Definicion de scanA}
\end{table}

Analogamente a como hicimos para el analisis de reduceA, supondremos primero que $\oplus$ es $O(1)$ en trabajo y profundidad, y consideraremos el conjunto $\mathcal{O}_s(\oplus,e,s)$ de aplicaciones de $\oplus$ al invocar \texttt{scanS $\oplus$ e s}.

\begin{itemize}
\item \textbf{Lema:} Para $W_\oplus,S_\oplus \in O(1)$, \texttt{scanA' $\oplus$ e s} es $O(|s|)$ en trabajo y $O(\log |s|)$ en profundidad.

 \textit{Dem:} De manera similar al analisis de reduceA, vemos que la recurrencia para el trabajo es $W(n) = W(n/2) + O(n)$, donde el $O(n)$  viene del trabajo de \texttt{tabulateA} y \texttt{contractA}, y el $W(n/2)$ del trabajo de la llamada recursiva (contractA reduce en un factor de 1/2 la secuencia). De donde el trabajo resulta $O(|s|)$. De la misma forma, la recurrencia para la profundidad es $S(n) = S(n/2) + O(1)$ donde el $O(1)$ viene de la profundidad de \texttt{contractA} y \texttt{tabulateA}, ambas $O(1)$. Resulta asi una profundidad de $O(\log |s|)$
\end{itemize}

Realicemos ahora un analisis general de costos.

\begin{itemize}
\item Veamos que \texttt{scanA} consiste esencialmente de dos llamadas en paralelo, una a \texttt{scanA'} y otra a \texttt{reduceA}.

\item Es muy importante notar que por esta razon, $\mathcal{O}_r(\oplus,e,s) \subseteq \mathcal{O}_s(\oplus,e,s)$

\item Por lo ya demostrado arriba, el trabajo de \texttt{scanA} queda $O(W[scanA'] + W[reduceA]) =$ $$O(|s| + \sum\limits_{(x\oplus y)\in\mathcal{O}_s(\oplus,e,s)} W[x\oplus y])$$

\item Para la profundidad, obtenemos $O(\max (S[scanA'], S[reduceA])) = $ $$O(\log |s|\cdot \max\limits_{(x\oplus y)\in\mathcal{O}_s(\oplus,e,s)} S[x\oplus y])$$
\end{itemize}
\subsubsection{showtA es $O(1)$ en trabajo y profundidad.}

\begin{table}[h]
\begin{lstlisting}
showtA x | n == 0    = EMPTY 
         | n == 1    = ELT (x ! 0)
         | otherwise = NODE (takeA x m) (dropA x m)
    where n = A.length x
          m = n//2
\end{lstlisting}
\caption{Definicion de showtA}
\end{table}

\begin{itemize}
\item \textbf{Lema:}  \texttt{takeA, dropA} son $O(1)$ en trabajo y profundidad.

 \textit{Dem:} Corolario de las cotas de \texttt{subArray}.

\end{itemize}

\texttt{showtA} realiza una cantidad constante de operaciones ya que no recursa e invoca funciones que realizan trabajo y profundidad constante.

\section{Implementacion basada en Listas}

\begin{tabular}{@{}lcc@{}}
\toprule
        & W & S \\ 
\midrule
filterS f s & $O(|s| + \sum\limits_{i=0}^{|s|-1} W[f\ s_i])$  & $O(|s| + \max\limits_{i} S[f\ s_i] )$  \\
showtS  & $O()$  &  $O()$ \\
reduceS f e s & $O(|s| + \sum\limits_{i=0}^{|s|/2} W[f\ s_{2i}\ s_{2i+1}])$  &  $O()$ \\
scanS   & $O()$  &  $O()$ \\ 
\bottomrule
\end{tabular}


\subsection{filterL es $O(|s| + \sum\limits_{i=0}^{|s|-1} W[f\ s_i])$ en trabajo, y $O(|s| + \max\limits_{i} S[f\ s_i] )$ prof.}

\begin{table}[h]
\begin{lstlisting}
filterL f []     = []
filterL f (x:xs) = 
    let (x',xs') = 
        (if f x then [x] else []) ||| (filterL f xs) 
    in x'++xs'
\end{lstlisting}
\caption{Definicion de filterL}
\end{table}
\begin{itemize}

\item \textbf{Trabajo de filterL:}

Teniendo como segundo argumento el largo de la secuencia $s$: \\
\\
    $W_{filter}(f, 0) = c_0$ \\
    $W_{filter}(f, n) = 1 + ( 1 + W($if $f\ s_0$ then $[x]$ else $[]) + W_{filter}(f, n-1) ) + W(x'++xs') = $ \\
\\
    Como el costo de 'if' es constante (además de construir el resultado), vemos rápidamente que el costo de esta primer expresión es $W(f\ s_0) + k$.
    Además, siendo $x'$ la asignación de este resultado, vemos que $x'++xs'$ también será de costo constante pues $x'$ será $[]$ o $[x]$ y la función $++$ depende del tamaño del primer argumento. Siguiendo:\\
\\
    $ = c_1 + W(f\ s_0) + W_{filter}(f, n-1) = ... = \sum\limits_{i=0}^{n-1} c_i + \sum\limits_{i=0}^{n-1} W[f\ s_i] $ \\
\\
    Donde se desprende $\sum\limits_{i=0}^{n-1} c_i$ de orden lineal más la sumatoria de costos de $f$ en los valores de la secuencia. Es decir: \\
\\
    $W_{filter} \in O(n + \sum\limits_{i=0}^{n-1} W[f\ s_i] ) = O(|s| + \sum\limits_{i=0}^{|s|-1} W[f\ s_i])$\\

\item \textbf{Profundidad de filterL:}

Similar a como analizamos el trabajo, tenemos: \\
\\
    $S_{filter}(f, 0) = c_0$ \\
    $S_{filter}(f, n) = 1 + ( 1 + max\{ S($if $f\ s_0$ then $[x]$ else $[]), S_{filter}(f, n-1)\} ) + S(x'++xs') = $ \\
\\
    Así como sucedía con el costo también sucede con la profundidad, en el caso del 'if' también tenemos $S(f\ s_0) + k$ y la profundidad de $++$ seguirá siendo constante. Siguiendo:\\
\\
    $ = c_1 + max\{ S(f\ s_0), S_{filter}(f, n-1) \} = c_1 + max\{ S(f\ s_0), c_2 + max\{S(f\ s_1), S_{filter}(f, n-2) \} \} \ (1) $ \\
\\
    Sea $S_f$ tal que $S_f = \max\limits_{0<=i<n} S(f\ s_i)$. \\
    Volviendo a $(1)$, reemplazando con $S_f$ nos queda:\\
\\
    $(1) \leq 
    c_1 + max\{ S_f, c_2 + max\{S_f, S_{filter}(f, n-2) \} \} \leq 
    c_1 + max\{ S_f, c_2 + max\{S_f, ... max\{ S_f, c_0 \} ... \} \} = $\\
\\
    Considerando el peor caso $c_0 < S_f$, esto resulta en:\\
\\
    $ = \sum\limits_{i=0}^{n-1} c_i + S_f $\\
\\
    Nuevamente se desprende de la primer sumatoria un orden lineal, sumado a $S_f$, el cual por definición era el máximo $S(f\ s_i)$ para algún $i$. Por lo tanto: \\
\\
    $S_{filter} \in O(n + \max\limits_{i} S[f\ s_i] ) = O(|s| + \max\limits_{i} S[f\ s_i] )$\\
    
\end{itemize}


\subsection{showtL es $O()$ en trabajo, y $O()$ prof.}

\begin{itemize}

\item \textbf{Trabajo de showtL:}


\item \textbf{Profundidad de showtL:}
    
\end{itemize}


\subsection{reduceL es $O()$ en trabajo, y $O()$ prof.}

\begin{itemize}

\item \textbf{Trabajo de reduceL:}


\item \textbf{Profundidad de reduceL:}
    
\end{itemize}


\subsection{scanL es $O()$ en trabajo, y $O()$ prof.}

\begin{itemize}

\item \textbf{Trabajo de scanL:}


\item \textbf{Profundidad de scanL:}
    
\end{itemize}    

\end{document}
